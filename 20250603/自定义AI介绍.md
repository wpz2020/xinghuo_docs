  * [](/)
  * 数据编辑器
  * 自定义AI介绍

复制链接

本页总览

# 自定义AI介绍

## 数据编辑器显示自定义AI类型[​](/Manual/DataEditor/CustomAI#数据编辑器显示自定义ai类型
"数据编辑器显示自定义AI类型的直接链接")

点击数据编辑器左上角的齿轮，在展开的类型面板中选择自定义AI设置。

![](https://doc.sce.xd.com/assets/images/打开AI数编01-a255640ea3d8a87fa995ec30afa7c4db.png)

![](https://doc.sce.xd.com/assets/images/打开AI数编02-bed3f4888d1104ba6e98a4ce7934d55e.png)

## 自定义AI节点属性[​](/Manual/DataEditor/CustomAI#自定义ai节点属性 "自定义AI节点属性的直接链接")

**AI搜索类型优先级：** 决定AI搜索器会优先搜索的目标，数值越大优先级便越高。例如英雄为3小兵为2野怪为1，那么会优先搜索到英雄，最后搜索到野怪。

**搜敌筛选：**
设置默认AI搜索器能搜索到的单位。必须：搜索到的单位必须拥有该类型。允许：搜索到的单位可以有或者没有该类型。不包括：搜索到的单位没有该类型。例如设置死亡为允许，则死亡单位也会被搜索到。

![](https://doc.sce.xd.com/assets/images/自定义AI节点属性-699d2de262748dc6bd23ac5e81babb42.png)

## 自定义AI结构[​](/Manual/DataEditor/CustomAI#自定义ai结构 "自定义AI结构的直接链接")

**添加时逻辑：** 在此AI被添加到单位身上时执行一次。例如给单位添加AI时会执行此逻辑。

**移除时逻辑：** 在此AI被从单位上移除时执行一次。例如单位进行了AI更换操作在新AI更换进单位之前便会执行此逻辑。

**应激逻辑** 每当单位受到敌方攻击时会执行此逻辑。例如单位被攻击或者技能命中时便会执行此逻辑。注意单位的AI关闭时依然有效

## 简单的行为树概念[​](/Manual/DataEditor/CustomAI#简单的行为树概念 "简单的行为树概念的直接链接")

行为树(Behavior
Tree)是一种用于控制复杂行为逻辑的决策框架。它是由多个节点组成的由根到叶的树状结构，其中每个节点代表一种特定的行为或决策。在行为树中，所有节点被分为两大类：控制节点和执行节点（叶节点）。

**控制节点：**
控制节点主要负责控制和决定下一个将要运行的主节点。一般包括顺序节点（Sequence）、选择节点（Selector）、并行节点（Parallel），以及装饰节点（Decorator）等。

  1. 顺序节点（Sequence）：它按顺序执行所有子节点，直到遇到一个返回失败结果的节点为止，否则会继续执行。如果所有节点都返回成功，那么它会执行完所有子节点并返回成功。

  2. 选择节点（Selector）：选择节点会尝试执行所有子节点，直到有一个返回成功，它就会停止执行并返回成功。如果所有节点都返回失败，那么它也会返回失败。

  3. 并行节点（Parallel）：这种节点会同时执行所有的子节点。根据设定的策略，当满足某种条件时，会停止执行并返回结果。

  4. 装饰节点（Decorator）:可以理解成一个修改节点。用于对其子节点进行功能的扩展、修饰或修改。

**执行节点（叶节点）：** 执行节点（Action
Node）是行为树中的叶子节点，表示具体的行为或操作，如移动、跳跃、攻击等。主要包括条件节点（Condition）行为节点（Action）。

  1. 条件节点（Condition）：判断动作条件是否满足，如果满足则返回Success，否则返回Failure。

  2. 行为节点（Action）：执行某个具体的动作或行为，例如移动、攻击、使用技能等。

## 自定义AI的行为树[​](/Manual/DataEditor/CustomAI#自定义ai的行为树 "自定义AI的行为树的直接链接")

**AI行为表**
自定义AI类似于一个顺序节点,它拥有一个AI行为表，在表中可以添加AI行为节点（叶节点），你需要在AI行为节点的AI行为函数中设计执行条件和行为。当AI行为节点返回假的时候，会接着执行下一个AI行为节点，返回真时则会直接打断AI行为节点，后面的AI行为节点也不会再执行。例如AI行为表中第一个AI行为节点，当单位在施法时会返回真，打断之后的AI行为节点，直到单位施法完成后返回假，之后的AI行为节点才会执行。

**AI行为表执行AI行为节点的顺序** AI行为表执行AI行为节点的顺序是表结构从上到下也就是1~N，例如图例中的AI行为表则是1开始12最后。

**AI行为表执行周期** AI行为表会每15帧执行一次。

![](https://doc.sce.xd.com/assets/images/自定义AI蓝图视图-ba394bb538a154ba7b6336375d212bd0.png)

## AI参数表中的参数（key）解释[​](/Manual/DataEditor/CustomAI#ai参数表中的参数key解释
"AI参数表中的参数（key）解释的直接链接")

**默认AI**

  * __ai_max_reset_range ：单位的重置距离，类型：数值。当单位的生成点超出此范围便会强制返回
  * __ai_born : 单位的生成点，类型：点。用于记录单位的生成点
  * __ai_target ：当前单位锁定的敌人，类型：单位。用于单位进行追击和攻击
  * __attacked_timer ： 攻击计时器，类型：计时器。用于控制单位追逐敌人的时间
  * __ai_walk_target ： 单位当前需要移动到的目标点，类型：点。用于非战斗时让单位移动到目标点
  * __ai_force_back ： 单位是否被强制返回，类型：布尔。为真时会激活强制返回
  * __ai_battle_walk_target：单位战斗时需要移动到的目标点，类型：点。用于战斗时让单位追击到目标点
  * __next_skill ： 单位将要释放的技能，类型：技能。用于单位释放技能
  * __ai_cast_timer ： 技能计时器，类型：计时器。用于控制单位技能释放流程

**沿路线移动**

  * path : 路线数组，类型：数组`<`点`>`。用于存储单位需要行走的路线点

  * attack_range ：搜敌范围，类型：数值。单位搜敌时的AI搜索器的搜索范围

  * cycle ： 是否循环路线，类型：布尔。用于判断单位是否循环路线行走，走到终点后会返回第一个点重新行走

  * daze_timer ： 发呆计时器，类型：计时器。用于控制单位发呆行为的计时器

  * pursue_time ： 追击时间，类型：数值。单位追击敌人的时间

  * pursue_timer ： 追击计时器，类型：计时器。用于控制单位追击敌人的行为

  * counter_attack ： 攻击计时器，类型：计时器。用于控制单位攻击敌人的行为

  * target_unit ： 目标单位，类型：单位。单位移动和攻击的目标

  * only_return ： 强制返回判断，类型：布尔。当超出追击距离时此布尔为真，会触发单位强制返回

  * target_point_battle ： 敌人目标点，类型：点。用于让单位追击到敌人附近的点

  * to_counter_point ：返回起点判断，类型：布尔。当超出追击距离时为真，会触发单位强制返回

  * counter_point ： 反击起点，类型：点。单位开始追击敌人前的自身坐标

  * pursue_distance : 追击距离，类型：数值。单位追击敌人时的最大追击距离，超出会触发返回

  * next_skill ： 单位将要释放的技能，类型：技能。用于单位释放技能

  * target_point ： 路线点的坐标，类型：点。用于单位按照路线行走的坐标

  * daze_time ： 发呆时间，类型：数值。单位抵达每一个路线点时暂留的时间

  * path_index ： 路线数组下标，类型：数组。用于获取单位当前所处的路线点，和下一个目标点

  * cast_skill ： 技能计时器，类型：计时器。用于控制单位技能释放流程 **召唤物跟随**

  * last_patrol_time : 上次巡逻的时间,类型：数值。召唤物开始执行巡逻行为时的时间

  * patrol_frequency ： 召唤物巡逻频率，类型：数值。召唤物巡逻的间隔时间

  * patrol_range ： 召唤物巡逻范围，类型：数值。召唤物的巡逻范围

  * search_range ： 召唤物搜敌范围，类型：数值。召唤物AI搜索器的搜敌距离

  * target_unit ： 目标单位，类型：单位。单位当前锁定的敌人

  * last_move_time ： 主人上次移动的时间，类型：数值。用于记录召唤物主人停止移动的时间

  * stay_time ： 主人停留时间，类型：数值。用于判断召唤物巡逻，当此时间小于主人停止移动的时间，召唤物开始巡逻流程

  * facing_to_master ： 召唤物是否在停留时朝向主人，类型：布尔。当为真时，召唤物在停留时会朝向主人

  * facing_to_master_timer ： 监测召唤物朝向计时器，类型：计时器。召唤物朝向主人流程控制计时器

  * master ： 召唤物的主人，类型：单位。召唤物的主人，用于召唤物的行为控制

  * order_move ： 召唤物其他运动行为的坐标点，类型：点。例如召唤物追击到敌人附近的点，召唤物跟随主人移动的点，随机移动的点

  * next_skill ：召唤物将要释放的技能，类型：技能。用于召唤物释放技能

  * cast_skill ： 技能计时器，类型：计时器。用于控制召唤物技能释放流程

## 默认AI与沿路线移动、召唤物跟随的介绍[​](/Manual/DataEditor/CustomAI#默认ai与沿路线移动召唤物跟随的介绍
"默认AI与沿路线移动、召唤物跟随的介绍的直接链接")

### 默认AI[​](/Manual/DataEditor/CustomAI#默认ai "默认AI的直接链接")

**添加时逻辑**
将单位的重置距离和追逐距离设置进AI参数表中(__ai_max_reset_range)、(__chase_range)，如果单位没有设置默认的追逐距离则将单位的搜敌距离设置为单位的追逐距离。如果单位没有设置默认的重置距离，则将其设置为单位的攻击范围加搜敌范围。

**应激逻辑**
先判断自身的合法性，如果合法则接着判断单位是否是被激怒以及目标(AI参数表(__ai_target))是否为空，如果是被激怒和为空，则设置AI参数表(__ai_target)为发出刺激的单位，并且命令单位强制追逐目标一段时间设置AI参数表(__attacked_timer)为追逐用的计时器。如果不满足激怒，则判断是否为逃跑，并且目标是否为空，接着判断单位是否可以移动，如果可以则命令单位随机走向周围设置AI参数表(__ai_walk_target)为周围的随机点。

**施法中** 判断单位是否在施法，是则打断行为节点，否则执行之后的节点

**失控** 判断但是是否失控，是则打断行为节点，否则执行之后的节点

**重置范围外无条件返回**
从AI的参数表中获取存储的单位创造点(__ai_born)。如果强制返回(__ai_force_back)被激活，并且单位可以移动，清空单位当前锁定的目标，让单位移动回创造点为止，然后取消强制返回的激活。

**战斗中移动**
从AI的参数表中获取存储的战斗移动点(__ai_battle_walk_target)和单位将要释放的技能(__next_skill)，如果战斗移动点存在，并且单位可以移动，没有将要释放的技能，那么便命令单位移动到战斗移动点并返回真打断之后的行为节点，否则将参数表中的战斗移动点设置为空。在单位移动到距离战斗移动点的附近时，清空单位的所有命令和行为，并设置参数表中的战斗移动点为空，然后返回假继续执行之后的行为节点。

**移动目标**
从AI的参数表中获取存储的闲置移动点(__ai_walk_target)和目标(__ai_target)，如果目标不为空，说明单位处于交战状态，则直接返回假，打断当前行为节点，执行之后的行为节点，否则判断单位的闲置移动点是否为空，以及单位是否可以移动，如果满足条件，则命令单位移动到闲置移动点并返回真打断之后的行为节点，当单位移动到闲置移动点附近后，清空单位的命令以及设置闲置移动点为空，返回假执行之后的行为节点。

**超出距离强制回初始点**
从AI的参数表中获取存储的单位的创造点(__ai_born)和重置距离(__ai_max_reset_range),如果单位可以移动并且单位的当前坐标和创造点的坐标距离超出了重置距离，便会激活强制返回(__ai_force_back),并先命令单位移动到创造点一次，返回真打断之后的行为节点。否则返回假执行之后的行为节点。

**超出追逐距离回初始点**
从AI的参数表中获取存储的单位的创造点(__ai_born)和目标(__ai_target),并获取单位的追逐距离和搜敌范围，如果单位没有设置默认的追逐距离，则设置单位的搜敌范围为单位的追逐距离。然后判断如果目标存在，单位和目标的距离大于追逐距离以及攻击计时器(__attacked_timer)为空(没有在进行强制追逐)，则命令单位忽视目标一段时间，并设置AI参数表中的目标(__ai_target)为空,同时判断单位能否进行移动，能则命令单位返回创造点，设置AI参数表中的闲置移动点(__ai_walk_target)为创造点。在判断之后返回真，打断之后的行为节点。如果不满足最初的判断那么便会直接返回假，不执行当前行为节点，执行之后的行为节点。

**搜敌人**
从AI的参数表中获取存储的目标(__ai_target)和存储的强制攻击追逐计时器(__attacked_timer),如果目标已经存在则先判断单位是否合法（不是无敌的，是个有效单位，还活着，是敌人等等），如果不合法则设置目标为空。如果单位为空，则使用AI搜索器执行搜索，如果搜索到了合法目标，重置攻击追逐计时器，命令单位强制追逐目标一段时间。

**没找到返回原点**
从AI的参数表中获取存储的目标(__ai_target)和单位的创造点(__ai_born),如果目标为空并且单位可以移动，则设置AI参数表中的(__ai_walk_target)为创造点，命令单位返回创造点并返回真打断之后的行为节点。如果目标不为空则返回假打断当前行为节点，执行之后的行为节点。

**找准备施放的技能**
从AI的参数表中获取存储的目标(__ai_target)和技能控制计时器(__ai_cast_timer)以及将要释放的技能(__next_skill)，如果将要释放的技能不为空，则打断当前行为节点，执行之后的行为节点，否则先判断是否拥有目标，如果目标存在则从AI中取一个随机可用的技能，并设置AI参数表的(__Next_skill)为该技能，同时重置技能控制计时器停止单位的移动(设置AI参数表中的(__ai_battle_walk_target)和(__ai_walk_target)为空)，当单位不能再计时器到期前释放掉该技能，则计时器便会清空单位的目标和将要释放的技能，并移除该计时器。

**找到技能就施放**
从AI的参数表中获取存储的目标(__ai_target)和技能控制计时器(__ai_cast_timer)以及将要释放的技能(__next_skill)，如果技能和目标都不为空，则判断单位释放成功释放技能，如果成功则移除计时器并设置AI参数表中的(__ai_cast_timer)、(__next_skill)、(__ai_battle_walk_target)为空，并返回真打断之后的行为节点。如果失败则直接直接返回假打断当前行为节点执行之后的行为节点。

**如果没技能但有目标就走一走**
从AI的参数表中获取存储的目标(__ai_target)和单位的出生点(__ai_born)以及重置范围(__ai_max_reset_range)，如果目标为空则直接打断该行为节点，否则判断是否存在追逐距离如果没有，设置搜敌距离为追逐距离，并设置走一走的值为追逐和普攻中的最小值，如果走一走为0，则设置走一走的值为单位的攻击范围，如果走一走小于300并且单位跟目标之间的距离大于300则假装追击目标，设置AI参数表(__ai_battle_walk_target)为目标。否则设置AI参数表(__ai_battle_walk_target)为空。

### 沿路线移动[​](/Manual/DataEditor/CustomAI#沿路线移动 "沿路线移动的直接链接")

**添加时逻辑**
初始化单位的数据，从AI参数表(path)获取线路转为数组后再存入(path),判断单位的搜索范围是否存在，如果不存在则设置为0再存入AI参数表(attack_range)，如果存在在直接存入。如果搜索范围为0则，设置AI参数表(counter_attack)为假不反击，否则设置真反击。同时获取AI参数表(cycle),如果为空，则设置为假(单位不循环路线)。之后设置停留时间为AI参数表中的(daze_time),设置反击时间为AI参数表中的(pursue_time),设置反击距离为AI参数表中的(pursue_distance),设置路径数组下标为AI参数表中的(path_index),设置当前的目标点为AI参数表中的(target_point),

**应激逻辑**
获取AI参数表(daze_timer)的发呆计时器、AI参数表(pursue_time)的追击时间、AI参数表(pursue_timer)的追击计时器。在单位受到应激后先判断刺激单位是否合法，如果不合法则直接返回空打断行为。如果是激怒行为，并且单位可以反击AI参数表(counter_attack)为真，单位当前没有目标，刺激的目标合法，单位没有在强制返回，则设置刺激单位为单位目标，并设置AI参数表的反击起点(counter_point)为当前单位坐标，然后判断是否存在发呆计时器(单位在发呆)，并重置单位的追击计时器。如果是逃跑行为，如果目标不为空，单位的反击距离大于0，单位没在强制返回，单位可以移动，则命令单位走向周围随机点，设置AI参数表(target_point_battle)为随机点。

**判断施法、失控** 如果单位在施法或者失控，则打断行为节点和之后的行为节点。

**强制返回反击起点**

从AI的参数表中获取存储的返回反击起点(to_counter_point)和反击起点(counter_point)和追击距离(pursue_distance)和目标(target_unit)。如果返回反击起点为真，则命令并且单位坐标和反击起点坐标距离大于50则设置目标为空，战斗移动点(AI参数表(target_point_battle))为空，将要释放的技能(AI参数表(next_skill))为空同时如果单位可以移动则命令单位返回起点在此判断后返回真打断之后的行为节点。当距离小于50时，将强制返回、反击起点、返回反击起点设置为空。如果最初的判断不满足，这判断单位是否超出追击距离，以及目标是否存在和合法，如果满足条件则激活强制返回和返回反击起点。

**到达目标点**
从AI的参数表中获取存储的目标点(target_point)和发呆时间(daze_time)和下标(path_index)和路径点数组(path)和是否循环(cycle)。判断单位是否到达地目标点并且没有目标，如果满足则判断单位是否能发呆，如果可以则设置发呆计时器(AI参数表(daze_timer))为计时器，控制单位发呆。然后判断单位是否走到终点，如果没有设置单位的下一个路线点，如果走到终点则判断单位是否循环路线，循环着重置路线点。

**战斗中移动**
从AI的参数表中获取存储的战斗移动点(target_point_battle)和要施放的技能(next_skill)。先判断如果单位可以移动，并且战斗移动点不为空，则命令单位移动到目标点，并返回真打断之后的行为节点，复杂设置AI参数表(target_point_battle)为空。

**搜敌**
从AI的参数表中获取存储的搜敌范围(attack_range)和目标(target_unit)。如果搜敌范围大于0或者目标为空，则执行一次A搜索器，如果新目标合法，则设置AI参数表的目标为新目标，设置AI参数表的(counter_point)为单位当前坐标，并检查是否存在发呆计时器存在则移除。如果搜敌范围大于0或者目标为空都不满足，则返回假打断该节点，执行之后的节点。

**没有目标就正常往目标点走**
从AI的参数表中获取存储的目标(target_unit)和目标点(target_point)和发呆计时器(daze_timer)。如果目标不为空，则检测目标是否合法，不合法则清空目标。接着判断如果目标不为空，单位不在发呆，单位可以移动，目标点不为空，单位不在目标点附近，则命令单位移动到目标点。

**有目标就找技能**
从AI的参数表中获取存储的目标(target_unit)和技能(next_skill)，判断如果存在目标，并且没有技能则使用AI寻找一个新技能，如果找到新技能，设置参数表的技能为新技能并设置技能计时器控制技能流程,如果计时器到期还未释放技能，则清空目标和技能。

**有技能有目标就施法**
从AI的参数表中获取存储的目标(target_unit)和技能(next_skill)，判断如果存在目标，和技能，则判断技能是否释放成功，如果释放成功则销毁技能计时器并清空目标和技能然后返回真打断之后的行为节点。否则返回假打断当前行为节点。

**没技能但是有目标就走一走**
从AI的参数表中获取存储的目标(target_unit)和反击起点(counter_point)和追击距离(pursue_distance)，如果没有目标则返回假，打断该行为节点执行之后的行为节点。如果单位普攻没有普攻距离则设置单位的走一走距离为攻击范围否则为普攻距离。如果目标走一走距离小于300假装追击目标。如果走一走的距离大于追击距离则重新随机走一走距离。

### 召唤物跟随[​](/Manual/DataEditor/CustomAI#召唤物跟随 "召唤物跟随的直接链接")

**添加时逻辑**
设置AI参数表中的(last_patrol_time)为当前游戏时间、如果没有设置巡逻频率(patrol_frequency)、巡逻范围(patrol_range)、搜敌范围(patrol_range)、主人停留时间(stay_time)、则设置其初始值，设置单位停留时朝向单位用循环计时器(facing_to_master)监测召唤物.

**移除时逻辑** 移除循环计时器AI参数表(facing_to_master)。

**判断失控、隐藏和施法** 如果召唤物处于失控、隐藏、施法状态，则返回真打断之后的行为节点。

**更新目标**
从AI的参数表中获取存储的目标(target_unit)和主人(master)和搜敌距离(search_range)和巡逻距离(patrol_range)，如果召唤物的搜敌距离为0，则直接返回假不搜敌执行之后的行为节点。如果目标不为空则判断目标的合法性，如果不合法则清空目标和技能。如果目标为空则检索主人的所有技能，寻找主人正在攻击的单位并设置其为目标。如果检索为空则执行AI搜索器搜敌，设置AI参数表的目标为检索到的目标。

**距离主人太远就清空目标**
从AI的参数表中获取存储的巡逻距离(patrol_range)和主人(master)和搜敌距离(search_range)。设置最远距离为搜敌距离+巡逻距离。如果召唤物跟主人在同一场景并且他们之间的距离超出最远距离，则设置AI参数表的目标、技能、其他移动(order_move)为空。

**有目标就找技能**
从AI的参数表中获取存储的目标(target_unit)和技能(next_skill)。先判断单位的合法性，如果不合法则清空目标。接着判断目标是否存在技能是否为空，如果满足条件则使用AI寻找一个可用的新技能，设置技能为新技能，重置技能计时器。

**有技能就尝试施法**
从AI的参数表中获取存储的目标(target_unit)和技能(next_skill)，判断如果存在目标，和技能，则判断技能是否释放成功，如果释放成功则销毁技能计时器并清空目标和技能然后返回真打断之后的行为节点。否则返回假打断当前行为节点。

**有目标没技能就走位**
从AI的参数表中获取存储的目标(target_unit)和主人(master)和追击距离(pursue_distance)，如果没有目标则返回假，打断该行为节点执行之后的行为节点。如果单位普攻没有普攻距离则设置单位的走一走距离(AI参数表(order_move))为攻击范围否则为普攻距离。如果目标走一走距离小于300假装追击目标。

**主人不动召唤物巡逻**
从AI的参数表中获取存储的巡逻范围(patrol_range)和主人(master)。先判断如果召唤物不在闲置或者不跟主人处于同一场景，返回假打断当前行为节点，如果主人在移动，更新主人的移动时间AI参数表(last_move_time)，并返回假打断当前行为节点。如果主人在停留，并且停留时间大于设定的主人停留时间，并且召唤物的停留时间大于设置的召唤物停留时间，则设置(order_move)为召唤物周围随机点，设置(last_patrol_time)为当前时间。

**主人动召唤物跟随**
从AI的参数表中获取存储的巡逻范围(patrol_range)和主人(master)。如果召唤物不在闲置切处于主人旁边则返回假打断当前行为节点。
如果主人在移动，则设置AI参数表(order_move)为主人周围的随机点。

**随机移动或者战斗移动**
从AI的参数表中获取存储的战斗移动点(order_move)和要施放的技能(next_skill)。如果召唤物可以进行移动并且战斗移动点存在、召唤物不在战斗移动点附近，则命令召唤物移动到战斗移动点，并返回真打断之后的行为节点，否则设置AI参数表(order_move)为空。

### 默认AI与沿路线移动、召唤物跟随的关键差异[​](/Manual/DataEditor/CustomAI#默认ai与沿路线移动召唤物跟随的关键差异
"默认AI与沿路线移动、召唤物跟随的关键差异的直接链接")

**默认AI** 默认AI的大多数行为基于出生点，他只会固定在出生点里进行搜敌，当检索到敌人时便会进行相应的行为。当强制返回时也会返回到出生点。

**沿路线移动AI跟默认AI差异**
沿路线移动AI会按照设置好的路线点移动，除非没有设置循环，否则会一直的移动下去，它的强制返回点不是固定的，会根据单位当前的坐标进行计算。你可以把他当成一个一直在移动的默认AI。

**召唤物跟默认AI差异**
召唤物的核心是主人，召唤物的所有行为都会先依赖于主人，例如搜敌时，会优先锁定到主人攻击的目标，当距离主人过远便会强制返回到主人旁边。同时他还有巡逻跟随主人。你可以把他当成一个出生点一直在他主人身上的一个默认AI，但是增加了巡逻和跟随行为。

**标签：**

  * [AI](/tags/ai)
  * [自定义AI](/tags/自定义ai)
  * [AI参数表](/tags/ai参数表)

[上一页表现节点解析](/Manual/DataEditor/ActorNode)[下一页自定义单位属性](/Manual/DataEditor/自定义单位属性)


