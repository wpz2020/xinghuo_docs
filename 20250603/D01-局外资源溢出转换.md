  * [](/)
  * 局外大厅预制功能
  * D01-局外资源溢出转换

复制链接

本页总览

# D01-局外资源溢出转换

前文提到局外资源中有一类型自定义局外资源，以及自定义类型资源获取函数，本文详细举例一种超过上限会【立刻】转换成另一种道具的实现方式

首先列出两种资源，以任何方式拥有英雄超过5个后转换为英雄碎片，英雄拥有数量字段记录为"英雄拥有数量"的通用型云变量（这个例子是纯数值，用货币型会更好，比通用型云变量少很多坑，但是这里需要展示更加通用的情况，因此用通用型云变量举例）

![](/assets/images/12-00fac2489ccdcea80fc9b4621f4e0611.png)
![](/assets/images/13-f764f801ea3c0768e0e74c133e70282c.png)

首先想到的是，在获取函数中，每次获取时先取云变量"英雄拥有数量"的值，然后判断增加当前获得数量后是否超过5个，未超过则将云变量"英雄拥有数量"更新为新的值，超过则进行溢出转换，函数内容如下

![](/assets/images/14-ce95d1b2800b9943db411e90d9039016.png)

此时我们到商城中添加商品，并测试购买若干次，若干数量

![](/assets/images/15-f133bc0264b509e7aa20308b82ba21b1.png)

可以看到如下log，当前已有2个英雄，一次性购买5个，溢出2个，乍一看没问题

![](/assets/images/16-bada686950bb38199d70586e8a6a5d37.png)

但是将商城中的商品修改一下，变为一次购买获得5个独立的英雄局外资源，并也在已有2个英雄的情况下，购买1次这个5组英雄在一起的商品

![](/assets/images/17-8a2e30c9e328d6c77332fb2584c526f4.png)
![](/assets/images/18-7b07934194bf2e86e8253edf6098abb3.png)

可以看到，分别执行了5次获得一个英雄，但实际最终却只获得了一个英雄，很显然，日志显示每次查询到的已拥有数量都为2，其原理在于，这里多次的获得独立局外资源，在获得了第一个局外资源时
**并没有** 真实地记录到云变量中，如果每次执行获取函数时都从原始云变量中取，必然只会取到原始值。

潜在的另一个问题是，获取多个独立局外资源时，会有大量的查询请求产生，很容易触发到每分钟查询上限，并且性能很差。

因此，在一次提交中，需要使用缓存记录未提交的云变量修改。

![](/assets/images/19-63feb6380487319e2b04c9d6253174a6.png)（没有这几个函数的需要勾选显示依赖库，并搜索到函数，显示详细设置，然后取消隐藏）

所以，对查询云变量部分代码做出如下改动，优先从缓存中获取英雄拥有数量，如果没有则进行查询，然后设置给缓存里。当然，也别忘了在处理完获取数量后，准备添加云变量提交操作时，把新的拥有数量也更新到缓存数据中

![](/assets/images/20-8a8189b71af263843f83a732fec88e11.png)
![](/assets/images/21-9ab57624365bab2f3997a34345700e2d.png)

新代码执行日志如下

![](/assets/images/22-b3074dd0c4e9a804a470a3484776c64e.png)

### 缓存的生命周期[​](/Manual/Homepage/CustomLobbyResource#缓存的生命周期 "缓存的生命周期的直接链接")

缓存数据会一直存在，直到手动调用清除缓存函数；或者是官方的一些局外资源提交，比如商城购买、邮件领取、抽奖获得等执行完毕后，不管成功与否，都会清除缓存

当自己手动进行云变量提交对象的创建，添加获得局外资源操作，并提交后，同样地需要手动调用清除缓存函数，以免缓存数据滞后造成的旧数据覆盖新数据现象发生。

**标签：**

  * [局外资源](/tags/局外资源)
  * [大厅相关](/tags/大厅相关)
  * [大厅商城](/tags/大厅商城)

[上一页D01-局外资源与大厅商城](/Manual/Homepage/HomepageStore)[下一页D01-大厅商城活动与跳转](/Manual/Homepage/HomepageStoreNotifiaction)


